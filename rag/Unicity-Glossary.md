# Unicity Glossary

## Agent
**Agent** is an “active” *Asset* in Unicity. It generally represents a program or another similar entity. Agents may communicate with each other and the rest of the world off-chain, but they post cryptographic commitments of their state on-chain so that other Agents can verify their claims about their state, particularly the uniqueness of the state. The latter ensures that an Agent can’t claim one state to one party and simultaneously another state to another party. Unicity Agents can be developed using the Agent SDK (in development).

## Aggregation Layer
**Aggregation Layer** maintains the system state, accepts updates from the *Execution Layer*, commits cryptographic summaries of the system state, along with *Consistency Proofs*, to the *Consensus Layer*, and provides *Inclusion* and *Exclusion* proofs to the *Execution Layer*. Unicity’s Aggregation Layer is implemented as a *Sparse Merkle Tree*.

## Asset
**Asset** in Unicity may be a *Token* or an *Agent*. Each Asset in Unicity has a unique identity.

## Authenticator
**Authenticator** authenticates commitment to the Aggregator Layer. Typically, this is a signature of the commitment’s payload corresponding to the public key from which the commitment’s request identifier has been derived.

## Blockchain Trilemma
**Blockchain Trilemma** is a concept, often discussed in the context of Ethereum, describing tradeoffs in blockchain design regarding decentralization, security, and scalability.

## Byzantine Fault Tolerance
**Byzantine Fault Tolerance** (**BFT**) is a property of distributed systems to continue operating correctly even when some components behave maliciously.

## CLOB (Central Limit Order Book)
**CLOB (Central Limit Order Book)** in the context of Unicity is an agent facilitating the exchange protocol. A party who wants to trade its token transacts it into the address referencing the escrow predicate generated by the CLOB agent. The escrow predicate encodes the trading order exchange and settlement conditions such as exchange rates, time frames, etc; as well as requests for CLOB providing proofs of correct and fair order matching and tokens atomic swap/settlement conditions (trading parties A and B can swap their tokens if both have locked their tokens into escrow predicates). The settlement happens off-chain and between the trading parties that follow SWAP protocol. Multiple parties execute settlements independently from each other and in parallel.

## Consensus Layer
**Consensus Layer** is the trust anchor for the other two layers. Its task is to ensure the uniqueness of the history of system state changes, thus eliminating forks that would allow double-spending of assets. Currently it consists of a *Proof of Work* chain and a *BFT Finality Gadget*. Transitioning from *Proof of Work* to *Proof of Stake* is planned as a future development.

## Consistency Proof
**Consistency Proof** shows that a data structure has been updated according to pre-agreed rules. Consistency Proofs from the *Aggregation Layer* to the *Consensus Layer* show that the transition from the previous system state to the current one only added new *Asset State Transitions* but did not remove or change any existing *Asset State Transitions*. Unicity currently supports *Hash-Based Proofs*. Transitioning to *Zero-Knowledge Proofs* is planned as a future development.

## Decentralized Autonomous Organizations (DAOs)
**Decentralized Autonomous Organizations (DAOs)** are Web2 applications where logic is implemented on agents performing verifiable computations on clients’ and interested parties’ machines, rather than on central servers. These agents can store and manipulate tokens.

## DEX (Decentralized Exchange)
**DEX (Decentralized Exchange)** is a set of agents executing the logic of an Automated Market Maker (AMM) and producing verifiable certificates of correct and fair execution. Each liquidity pair is served by a separate agent.

## Exclusion Proof
**Exclusion Proof** of an authenticated data structure allows the recipient to verify that an entry is absent from the structure. An Exclusion Proof from Unicity’s *Aggregation Layer* shows that an *Asset*’s state has not been spent (that is, this was the *Asset*’s current state at the time when the proof was generated).

## Execution Layer
**Execution Layer** maintains and evolves the states of individual *Assets*. In Unicity, the Execution Layer is implemented completely off-chain. Each *Asset* is implemented as its own unit within its own execution environment, using tools chosen by the developers of that *Asset*. Only the cryptographic *Authenticators* of *Asset State Transitions* are posted on-chain.

## Finality Gadget
**Finality Gadget** is a blockchain component using *BFT* principles to provide deterministic finality. Unicity’s Finality Gadget uses a version of the *HotStuff* protocol to achieve high performance.

## Hash-Based Consistency Proof
**Hash-Based Consistency Proof** is a type of *Consistency Proof*. It includes a sample of intermediate hash values from the *SMT* that allows the *Consensus Layer* to verify that the transition from the previous system state to the current one only added new *Asset State Transitions* but did not remove or change any existing *Asset State Transitions*. The size of the Hash-Based Proof is approximately linear in the number of *Asset State Transitions* and logarithmic in the size of the system state.

## HotStuff
**HotStuff** is a leader-based *BFT* consensus protocol designed for high performance and simplicity.

## Inclusion Proof
**Inclusion Proof** of an authenticated data structure allows the recipient to verify that an entry is present in the structure. An Inclusion Proof from Unicity’s *Aggregation Layer* shows that an *Asset State Transition* request has been accepted and included in the global system state and thus acts as a receipt of the action that the *State Transition* represents (such as the transfer of the ownership of a *Token*).

## Ledger
**Ledger** in traditional blockchain designs is an append-only record of assets maintained by network nodes.

## Nametag Tokens
**Nametag Tokens** are addressable self-authenticated data structures encoded within Unicity *Tokens* that map arbitrary names to app-specific values. Unicity ensures that once a name is claimed, it cannot be claimed by someone else.

## Off-chain
**Off-chain** - operations or data that are not directly recorded on the blockchain. In Unicity, *Assets* and their processing primarily occur off-chain.

## On-chain
**On-chain** - operations or data that are directly recorded and processed on the blockchain.

## Oracles
**Oracles**: implemented as a network of agents committing and certifying on some data (like, readings of real-world data, VRN generators, etc).

## Owner Predicate
**Owner Predicate** is a *Predicate* that defines the conditions for transferring the ownership of a *Token*. In Unicity, the input to an Owner Predicate is a *State Transition* and the output is a verdict whether the transition is allowed. A typical example of Owner Predicate is “Pay to Public Key”. Such a *Predicate* contains the cryptographic public key of the current owner of the *Token* and returns True only if the *State Transition* is correctly signed with the private key corresponding to the public key embedded in the *Predicate*.

## Predicate
**Predicate** is a function that gets some input and returns either True or False. In Unicity, Predicates, such as *Owner Predicates*, are used to define conditions for manipulating *Tokens*.

## Programmability
**Programmability** - a term preferred over “smart contracts” in Unicity, encompassing both single-asset programmability (using *Predicates*) and multi-asset programmability (using *Agents*).

## Proof of Stake
**Proof of Stake** (**PoS**) is a decentralized consensus mechanism where each party’s voting power is determined by the stake it holds in the system.

## Proof of Work
**Proof of Work** (**PoW**) is a decentralized consensus mechanism where each party’s voting power is determined by the amount of computational resources it spends. Unicity’s PoW chain is based on Bitcoin, but uses the *RandomX* hash function for GPU and ASIC resistance.

## RandomX
**RandomX** is a CPU-optimized hashing algorithm, resistant to GPU-based optimizations and ASIC-based implementations, ensuring fair mining participation.

## Software Development Kit
**Software Development Kit** (**SDK**) - tools provided for developers to build on Unicity. The State Transition SDK is for manipulating tokens, and the Agent SDK (under development) is for building decentralized applications.

## Sparse Merkle Tree
**Sparse Merkle Tree** (**SMT**) is an authenticated data structure for managing a dictionary of key-value pairs. It is a specialized form of hash tree that supports issuing both *Inclusion* and *Exclusion* proofs about its contents. In Unicity’s *Aggregation Layer*, the hash of the previous state of an *Asset* (including its *Owner Predicate*) is the key and an *Authenticator* of the new state is the value of each entry in the dictionary. Since the dictionary is append-only (new entries can be added to it, but no existing entries can be removed or changed), each *Asset* state can only be spent once.

## State Transition
**State Transition** is a change of state of an *Asset*. Each State Transition in Unicity is eventually registered on-chain to be verifiably unique. State Transitions are represented on-chain via cryptographic *Authenticators*.

## Token
**Token** is a “passive” *Asset* in Unicity. It generally represents something of value. Among the attributes of a Token, such as its identity, type, and value, an important one is the *Owner Predicate* that defines the conditions for manipulating the Token. Unicity Tokens can be created and manipulated using the State Transition SDK.

## Unicity
**Unicity** is a blockchain protocol that enables off-chain, verifiable execution of decentralized applications using agents, with strong cryptographic guarantees. Unicity consists of *Consensus*, *Aggregation* and *Execution* layers.

## Zero-Knowledge Consistency Proof
**Zero-Knowledge Consistency Proof** is a type of *Consistency Proof*. It uses techniques from Zero-Knowledge (ZK) proof systems to show that the transition from the previous system state to the current one only added new *Asset State Transitions* but did not remove or change any existing *Asset State Transitions*. The size of the Zero-Knowledge Proof is independent of the number of *Asset State Transitions* and the size of the system state.